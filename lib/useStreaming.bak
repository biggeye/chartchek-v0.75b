import { useState, useCallback, useRef } from 'react'
import type { Message, MessageContent, MessageRole } from '@/types/api/openai'
import { useAssistantStore } from '@/store/assistantStore'
import { processAssistantResponse } from '@/lib/assistant/services';

interface UseStreamingReturn {
  streamingContent: MessageContent[]
  handleStream: () => Promise<void>
  setStreamingContent: React.Dispatch<React.SetStateAction<MessageContent[]>>
}

export const useStreaming = (): UseStreamingReturn => {
  const assistantId = useAssistantStore((state) => state.currentAssistant?.assistant_id)
  // Note: your currentThread in the store should be set by your component (as you did with setThreadId)
  const threadId = useAssistantStore((state) => state.currentThread?.thread_id)
  const [streamingContent, setStreamingContent] = useState<MessageContent[]>([])
  const activeRunRef = useRef<string | null>(null)
  const abortCtrlRef = useRef<AbortController | null>(null)
  // For accumulating the full message text and any annotations
  const accumulated = useRef<{ currentText: string; annotations: any[] }>({
    currentText: '',
    annotations: []
  }).current

  // This function is called to start and handle a streaming run.
  // It uses similar logic as your old code so that:
  // • A textCreated event initializes the message (and you could create an initial store entry)
  // • textDelta events update the currently streaming message in state
  // • The final “end” event posts the full message to your backend and clears the streaming UI.
  const handleStream = useCallback(async () => {
    if (abortCtrlRef.current) {
      abortCtrlRef.current.abort()
    }
    abortCtrlRef.current = new AbortController()

    // Reset accumulated text for this run
    accumulated.currentText = ''
    accumulated.annotations = []

    let reader: ReadableStreamDefaultReader<Uint8Array> | null = null;

    try {
      const runResponse = await fetch('/api/thread/run/stream', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          thread_id: threadId,
          assistant_id: assistantId
        }),
        signal: abortCtrlRef.current.signal
      })

      if (!runResponse.ok) {
        const errData = await runResponse.json().catch(() => null)
        console.error('[AssistantChat] Failed to start run:', errData)
        throw new Error(errData?.error || 'Failed to start run')
      }

      reader = runResponse.body?.getReader() ?? null;
      if (!reader) {
        throw new Error('No response stream available')
      }

      activeRunRef.current = Date.now().toString()
      const decoder = new TextDecoder('utf-8')
      let done = false
      let messageStarted = false;

      while (!done) {
        const { value, done: readerDone } = await reader.read();
        done = readerDone;

        if (value) {
          const chunk = decoder.decode(value, { stream: true });
          accumulated.currentText += chunk;
          // Split into individual lines (each line begins with "data: ")
          const lines = chunk.split('\n').filter(line => line.trim() !== '');
          for (const line of lines) {
            if (line.startsWith('data: ')) {
              const data = JSON.parse(line.slice(6));
              // When the assistant message starts, create an initial empty message.
              if (data.type === 'textCreated') {
                messageStarted = true;
                accumulated.currentText = '';
                accumulated.annotations = [];
              }
              // Append incremental content to the streaming message.
              else if (data.type === 'textDelta' && messageStarted) {
                const delta = data.data?.delta?.value || '';
                const newAnnotations = data.data?.delta?.annotations || [];
                accumulated.currentText += delta;
                accumulated.annotations = [...accumulated.annotations, ...newAnnotations];
                // Update the streaming content.
                setStreamingContent((prev: MessageContent[]) => {
                  console.log('[useStreaming] Updating streaming content:', {
                    prev,
                    delta,
                    newAnnotations
                  });
                  if (prev.length > 0) {
                    // Append delta to the last element.
                    const last = prev[prev.length - 1];
                    const updatedText = last.text.value + delta;
                    const updatedAnnotations = [
                      ...(last.text.annotations || []),
                      ...newAnnotations
                    ];
                    return [
                      ...prev.slice(0, -1),
                      { type: 'text', text: { value: updatedText, annotations: updatedAnnotations } }
                    ];
                  } else {
                    return [{ type: 'text', text: { value: delta, annotations: newAnnotations } }];
                  }
                });
              }
              // When the stream ends, store the assistant message.
              else if (data.type === 'end' && messageStarted) {
                // Log the accumulated message before storing
                // Create a timestamp
                const timestamp = new Date().toISOString();

                // Use the timestamp in your logic
                // Prepare the data to store the assistant's final message.
                const formData = new FormData();
                formData.append('message_id', timestamp);
                formData.append('thread_id', threadId!);
                formData.append('content', accumulated.currentText);
                formData.append('annotations', JSON.stringify(accumulated.annotations));
                formData.append('role', 'assistant');
                console.log('[useStreaming] FormData prepared:', {
                  thread_id: threadId,
                  content: accumulated.currentText,
                  annotations: accumulated.annotations,
                  role: 'assistant'
                });
                const storeRes = await fetch('/api/thread/message', {
                  method: 'POST',
                  body: formData,
                });

                if (!storeRes.ok) {
                  console.error('[AssistantChat] Failed to store assistant message:', await storeRes.text());
                } else {
                  const storeData = await storeRes.json();
                  console.log('[AssistantChat] Stored assistant message:', storeData);
                }
                // Clear the streaming content once the message is complete.
                setStreamingContent([]);
              }
              // If there is an error event.
              else if (data.type === 'error') {
                activeRunRef.current = null;
                throw new Error(data.data);
              }
              // In case of duplicate "end" events.
              else if (data.type === 'end') {
                activeRunRef.current = null;
              }
            }
          }
        }
      }

      // Finalize the streaming process
      accumulated.currentText = '';
      accumulated.annotations = [];

    } catch (error: any) {
      console.error('[AssistantChat] Error:', error)
      // Option: bubble up the error by setting an error state in your component.
    } finally {
      if (reader) {
        reader.releaseLock();
      }
      abortCtrlRef.current = null
    }
  }, [assistantId, threadId, setStreamingContent, accumulated])

  return {
    streamingContent,
    handleStream,
    setStreamingContent
  }
}

export default useStreaming